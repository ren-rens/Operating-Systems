# Условие
Дадена е програма за ОС Linux, написана на езика C:
```
#include <unistd.h>
#include <string.h>
int main(void)
{
char* buff = "Hello world!\n";
int p;
if (fork()==0) write(1,buff,strlen(buff));
p=fork();
write(1,buff,strlen(buff));
}
```

1. Колко пъти ще се отпечата текста Hello world! при изпълнението на програмата? Обосновете отговора си.
2. Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник.

## Анализ на изпълнението
Програмата използва fork(), което клонира текущия процес и създава нов. След всяко извикване на fork(), се създава нов процес, който продължава изпълнението от същото място.
### Стъпки на изпълнението
1. Процес P0 (начален процес):
* Извиква fork() → създава P1
  * В P1 fork() == 0, така че P1 извършва write() → 1 печат
* В P0 fork() != 0, не изпълнява write() на този ред.

2. След това и двата процеса (P0 и P1) изпълняват p = fork();

Оттук възникват още процеси:
* P0 → fork() → създава P2
* P1 → fork() → създава P3

След fork(), всеки от P0, P1, P2, и P3 изпълняват write():
* P0 → write → 1 печат
* P1 → write → 1 печат (втори за P1)
* P2 → write → 1 печат
* P3 → write → 1 печат

### Обща бройка на отпечатванията:
* P1 → 1 печат от първия write(), 1 печат от втория → 2 пъти
* P0 → само втория write() → 1 път
* P2 → от втория write() → 1 път
* P3 → от втория write() → 1 път

Общо: 2 (P1) + 1 (P0) + 1 (P2) + 1 (P3) = 5 пъти

## Дърво на процесите:
```
        P0
       /  \
     P1    P2
     |
    P3
```
* P0 → създава P1 (от първия fork())
* P0 → създава P2 (от втория fork())
* P1 → създава P3 (от втория fork() в P1)
